#pragma once

#include <optional>

#include "nldb/Property/Property.hpp"
#include "nldb/typedef.hpp"

namespace nldb {
    struct ValueObjectMapped {
        int id;
        int doc_id;
        int prop_id;
        int sub_coll_id;
        int sub_doc_id;
    };

    class IValuesDAO {
       public:
        /**
         * @brief Adds a new value to an object
         *
         * @param propID
         * @param objID
         * @param type any type but OBJECT is allowed.
         * @param value
         */
        virtual void addStringLike(int propID, snowflake objID,
                                   PropertyType type, std::string value) = 0;

        /**
         * @brief Due to the low transaction speeds and small data generated by
         * addStringLike, it makes more sense to add all the values at one,
         * avoiding continuos slow transactions.
         *
         * This defer should define a limit on the pending data.
         *
         * This pending data should be sent when this limit is reached, whether
         * "pushPendingData" is called or the destructor is called.
         *
         * @param propID
         * @param objID
         * @param type
         * @param value
         */
        virtual void deferAddStringLike(int propID, snowflake objID,
                                        PropertyType type,
                                        std::string value) = 0;

        /**
         * @brief if there is data pending to be sent, make sure it is sent.
         *
         */
        virtual void pushPendingData() = 0;

        /**
         * @brief adds a new object to a property.
         * This means that the object is not a value of another object, instead
         * it's value of a collection (a document).
         *
         * @param propID
         * @param objID
         */
        virtual snowflake addObject(int propID) = 0;

        /**
         * @brief gives you the new object id and later inserts it into the db.
         *
         * @param propID
         * @return snowflake_size
         */
        virtual snowflake deferAddObject(int propID) = 0;

        /**
         * @brief adds a new object to an object
         *
         * @param propID
         * @param docID
         * @param objID
         */
        virtual snowflake addObject(int propID, snowflake objID) = 0;

        /**
         * @brief gives you the new object id and later inserts it into the db.
         *
         * @param propID
         * @param objID
         * @return snowflake_size
         */
        virtual snowflake deferAddObject(int propID, snowflake objID) = 0;

        /**
         * @brief Updates a document property value.
         *
         * @param propID
         * @param objID
         * @param type any type but OBJECT is allowed.
         * @param value
         */
        virtual void updateStringLike(int propID, snowflake objID,
                                      PropertyType type, std::string value) = 0;

        /**
         * @brief Check if a document property has value.
         *
         * @param propID
         * @param objID
         * @param type
         * @return true
         * @return false
         */
        virtual bool exists(int propID, snowflake objID, PropertyType type) = 0;

        virtual bool existsObject(snowflake objID) = 0;

        /**
         * @brief finds a value object given its prop id and the parent id
         *
         * @param propID
         * @param objID
         * @return optional<snowflake_size>
         */
        virtual std::optional<snowflake> findObjectId(int propID,
                                                      snowflake objID) = 0;

        /**
         * @brief Removes an object and all the values associated with it.
         *
         * @param objID
         */
        virtual void removeObject(snowflake objID) = 0;
    };
}  // namespace nldb